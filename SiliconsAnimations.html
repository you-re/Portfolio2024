<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silicons Animations</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    
    <!-- Link to Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

    <style>
        /* Reset some default browser styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* General body styling */
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #cecece;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            text-align: center;
        }

        /* Container to center everything */
        .container {
            max-width: 1000px;
            background-color: #fff;
            border: 1px solid #333;
            border-bottom: 0px;
            margin: 0 auto;
            padding: 0; /* Remove padding */
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; /* Align to the left */
        }

        /* Header and paragraph box styling */
        .content-box {
            background-color: #fff;
            border-bottom: 1px solid #333;
            width: calc(100%); /* Full width minus padding */
            margin: 0; /* No margin */
            padding: 10px; /* Reduced padding for a tighter fit */
            text-align: center; /* Center text */
        }

        .content-box iframe {
            width: 80%;
            height: 500px;
            border: 20px;
        }
        /* Additional style for top border */
        .content-box.has-top-border {
            border-top: 1px solid #333; /* Add top border */
        }

        /* Additional style for grid items */
        .grid-item {
            background-color: #fff;
            border-right: 1px solid #333; /* Default right border */
            margin: 0; /* Remove margin for touching containers */
            padding: 0; /* Remove padding for touching containers */
            width: calc(25%); /* 4 items per row */
            text-align: center;
            position: relative; /* For positioning of the description */
            transition: opacity 0.5s ease, transform 0.5s ease; /* Smooth transition */
        }

        .grid-item a {
            display: block; /* Make anchor fill the grid item */
            height: 0; /* Initialize height for square box */
            padding-bottom: 100%; /* Maintain square aspect ratio */
            position: relative; /* For absolute positioning of the image */
            overflow: hidden; /* Prevent overflow when zooming */
        }

        .grid-item img {
            position: absolute; /* Position the image absolutely within the anchor */
            top: 50%; /* Center vertically */
            left: 50%; /* Center horizontally */
            width: 90%; /* Image occupies 100% of the box */
            height: auto; /* Maintain aspect ratio */
            transform: translate(-50%, -50%); /* Center image */
            transition: transform 0.3s ease; /* Smooth transition for zoom effect */
        }

        .description {
            font-weight: 300;
            margin: 0; /* Remove margin */
            color: #333;
            padding: 2%; /* Padding for description */
            background-color: #fff; /* Match background with the grid item */
            border-top: 1px solid #333; /* Border above description */
            text-align: center; /* Center text in the description box */
        }

        /* Main header styling */
        h1 {
            text-transform: uppercase;
            font-weight: 150;
            font-size: 2em;
            color: #333;
        }

        /* Subheader styling */
        h2 {
            text-transform: uppercase;
            font-weight: 200;
            color: #333;
            font-size: 1.5em;
        }

        /* Description paragraph */
        p {
            font-family: 'Old Standard TT', serif;
            font-weight: 100;
            font-size: 1em;
            color: #333;
            padding-inline: 10%;
            text-align: left;
        }

        /* Footer box styling */      
        footer {
            background-color: #fff;
            font-weight: 300;
            font-size: 0.8em;
            color: #333;
            text-align: center;
        }

        footer a {
            text-decoration: none;
            color: #333;
        }

        @media (max-width: 5000px) {
            .grid-item {
                width: calc(50%); /* 3 items per row */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content-box">
            <h1>Silicons Animations</h1>
        </div>

        <div class="content-box">
            <h2>Task Description</h2>
            <p>The client needed an efficient method to create thousands of NFT animations from a set of 100+ assets. My responsibilities included character animation, clothing simulations, automating the rendering and optimizing the workflow.</p>
        </div>

        <div class="content-box">
            <iframe autoplay loop muted src="https://github.com/user-attachments/assets/d8a16680-c308-48f1-8d20-a2e752f09f11" alt="Walk Cycle Animation"></iframe>
        </div>

        <div class="content-box">
            <h2>Thought Process</h2>
            <p>
                Initially, I considered rendering each combination of assets separately, but I quickly realized this would lead to extremely long render times. Instead, I chose to render each asset as a separate layer and then composite them in After Effects.
            </p>
        </div>

        <div class="content-box">
            <iframe autoplay loop muted src="https://github.com/user-attachments/assets/c7b7180f-1604-43c2-82d3-74b278747077" alt="3D assets video loop"></iframe>
        </div>

        <div class="content-box">
            <h2>Optimizations</h2>
            <p>This approach avoided redundant rendering of the same assets multiple times, reducing the overall render time by reusing the same renders across combinations. It also allowed for fast fixes in case any of the assets needed that.</br>
            After optimizing and simulating garments, I batch imported everything into Blender, ensuring materials and animations were correct. I used a Python script to automate individual asset rendering.
            </p>
        </div>

        <div class="content-box">
            <iframe autoplay loop muted src="https://github.com/user-attachments/assets/d73d5342-b77b-4557-b915-4bafd8ba30c5" alt="Video of the Compositing Process"></iframe>
        </div>

        <div class="content-box">
            <h2>Tools Used</h2>
            <p>
                <strong>- Blender: </strong> Used primarily for character animation and batch asset rendering with Python scripts.</br>
                <strong>- Marvelous Designer: </strong> Simulated and designed realistic clothing for characters.</br>
                <strong>- Houdini: </strong> Managed looping simulations for seamless animations, particularly with clothing and dynamics.</br>
                <strong>- Python: </strong> Automated the rendering process, including asset imports, materials, and animation setups.</br>
                <strong>- Adobe After Effects: </strong> Composited asset layers and created final NFT animations by managing combinations.</br>
                <strong>- JavaScript/Adobe ExtendScript: </strong> Automated the compositing process in After Effects, ensuring efficient handling of multiple asset layers and variations.
            </p>
        </div>
        
        <div class="content-box">
            <footer>© 2024 <a href="https://www.linkedin.com/in/jure-suli%C4%8D-9b700a195/">Jure Sulič</a></footer>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const contentBoxes = document.querySelectorAll('.content-box');
            const gridItems = document.querySelectorAll('.grid-item');
    
            // Add top border for content boxes
            contentBoxes.forEach(contentBox => {
                const previousElement = contentBox.previousElementSibling;
                if (previousElement && previousElement.classList.contains('grid-item')) {
                    contentBox.classList.add('has-top-border');
                }
            });
            
            // -----------------------------
            /*
            // Function to check and set borders for grid items
            function updateGridBorders() {
                const container = document.querySelector('.container');

                gridItems.forEach((gridItem, index) => {
                    // Reset borders
                    gridItem.style.borderRight = '1px solid #333'; // Default right border
                    // gridItem.style.borderTop = '1px solid #333';   // Default top border

                    // Get the width percentage of the grid item
                    const widthPercent = getGridItemWidthInPercent(gridItem);

                    // Get the count of previous grid items
                    const previousGridItemsCount = Array.from(gridItems).slice(0, index).filter(item => item.offsetParent !== null).length;

                    // Check conditions based on width percentage
                    if (widthPercent === 100) {
                        gridItem.style.borderRight = '1px solid #fff'; // No borders
                    } else if (widthPercent === 50) {
                        if ((previousGridItemsCount + 1) % 2 === 0) {
                            gridItem.style.borderRight = '1px solid #fff'; // Remove right border for odd previous items
                        }
                    } else if (widthPercent < 50 && widthPercent > 25 ) { // Check for less than 50%
                        if ((previousGridItemsCount + 1) % 3 === 0) {
                            gridItem.style.borderRight = '1px solid #fff'; // Remove right border for non-last in group of 3
                        }
                    } else if (widthPercent < 30) { // Check for less than 50%
                        if ((previousGridItemsCount + 1) % 4 === 0) {
                            gridItem.style.borderRight = '1px solid #fff'; // Remove right border for non-last in group of 3
                        }
                    } else {
                        gridItem.style.borderRight = '1px solid #333';
                    }
                });
            }
            */

            // Function to check and set borders for grid items
            function updateGridBorders() {
                const container = document.querySelector('.container');

                gridItems.forEach((gridItem, index) => {
                    // Reset borders
                    gridItem.style.borderRight = '1px solid #333'; // Default right border
                    // gridItem.style.borderTop = '1px solid #333';   // Default top border

                    // Get the width percentage of the grid item
                    const widthPercent = getGridItemWidthInPercent(gridItem);

                    // Get the count of previous grid items
                    const previousGridItemsCount = Array.from(gridItems).slice(0, index).filter(item => item.offsetParent !== null).length;

                    // Check conditions based on width percentage
                    if (index % 2 === 1){
                        gridItem.style.borderRight = '1px solid #fff';
                    } else {
                        gridItem.style.borderRight = '1px solid #333';
                    }
                });
            }

            // Function to get the width of a grid item in percentage
            function getGridItemWidthInPercent(gridItem) {
                const container = document.querySelector('.container');
                const gridItemStyle = window.getComputedStyle(gridItem);
                const gridItemWidth = parseFloat(gridItemStyle.width);
                const containerWidth = container.clientWidth;
                const widthPercent = (gridItemWidth / containerWidth) * 100;
                return widthPercent;
            }

            // Initial check
            updateGridBorders();

            // Update on window resize
            window.addEventListener('resize', updateGridBorders);
        });
    </script>
</body>
</html>
