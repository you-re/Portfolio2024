<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Culler Node</title>
    
    <!-- Link to Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

    <style>
        /* Reset some default browser styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* General body styling */
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #cecece;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            text-align: center;
        }

        /* Container to center everything */
        .container {
            max-width: 1000px;
            background-color: #fff;
            border: 1px solid #333;
            border-bottom: 0px;
            margin: 0 auto;
            padding: 0; /* Remove padding */
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; /* Align to the left */
        }

        /* Header and paragraph box styling */
        .content-box {
            background-color: #fff;
            border-bottom: 1px solid #333;
            width: calc(100%); /* Full width minus padding */
            margin: 0; /* No margin */
            padding: 10px; /* Reduced padding for a tighter fit */
            text-align: center; /* Center text */
        }

        .content-box iframe {
            width: 80%;
            height: 500px;
            border: 20px;
        }
        /* Additional style for top border */
        .content-box.has-top-border {
            border-top: 1px solid #333; /* Add top border */
        }

        /* Additional style for grid items */
        .grid-item {
            background-color: #fff;
            border-right: 1px solid #333; /* Default right border */
            margin: 0; /* Remove margin for touching containers */
            padding: 0; /* Remove padding for touching containers */
            width: calc(25%); /* 4 items per row */
            text-align: center;
            position: relative; /* For positioning of the description */
            align-self: center;
            justify-self: center;
        }

        .grid-item a {
            display: block; /* Make anchor fill the grid item */
            height: 0; /* Initialize height for square box */
            padding-bottom: 100%; /* Maintain square aspect ratio */
            position: relative; /* For absolute positioning of the image */
            overflow: hidden; /* Prevent overflow when zooming */
        }

        .grid-item img {
            position: absolute; /* Position the image absolutely within the anchor */
            top: 50%; /* Center vertically */
            left: 50%; /* Center horizontally */
            width: 90%; /* Image occupies 100% of the box */
            height: auto; /* Maintain aspect ratio */
            transform: translate(-50%, -50%); /* Center image */
            transition: transform 0.3s ease; /* Smooth transition for zoom effect */
        }

        .grid-item video {
            position: absolute; /* Position the image absolutely within the anchor */
            top: 50%; /* Center vertically */
            left: 50%; /* Center horizontally */
            width: 90%; /* Image occupies 90% of the box */
            height: auto; /* Maintain aspect ratio */
            transform: translate(-50%, -50%); /* Center image */
        }

        .description {
            font-weight: 300;
            margin: 0; /* Remove margin */
            color: #333;
            padding: 2%; /* Padding for description */
            background-color: #fff; /* Match background with the grid item */
            border-top: 1px solid #333; /* Border above description */
            text-align: center; /* Center text in the description box */
        }

        /* Main header styling */
        h1 {
            text-transform: uppercase;
            font-weight: 150;
            font-size: 2em;
            color: #333;
        }

        /* Subheader styling */
        h2 {
            text-transform: uppercase;
            font-weight: 200;
            color: #333;
            font-size: 1.5em;
        }

        p {
            font-family: 'Old Standard TT', serif;
            font-weight: 100;
            font-size: 1em;
            color: #333;
            padding-inline: 10%;
            
            text-align: left;
        }

        p.strong {
            font-weight: 400;
        }

        p.justify {
            text-align: right;
        }

        /* Footer box styling */      
        footer {
            background-color: #fff;
            font-weight: 300;
            font-size: 0.8em;
            color: #333;
            text-align: center;
        }

        footer a {
            text-decoration: none;
            color: #333;
        }

        @media (max-width: 5000px) {
            .grid-item {
                width: calc(50%); /* 3 items per row */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content-box">
            <h1>Camera Culler Node for Blender</h1>
        </div>

        <div class="content-box">
            <h2>Overview</h2>
            <p>The Camera Culler is a custom tool developed for Blender to significantly improve rendering efficiency through optimized camera culling. It enables faster rendering by selectively processing only the objects within the camera’s view, reducing computation time and memory usage.</p>
        </div>

        <div class="content-box">
            <h2>How it works</h2>
            <p>The initial proof of concept used ray casting to determine whether a point was visible to the camera. However, this was later optimized for greater efficiency. In the final version, point positions are directly projected onto the camera’s screen space, which leads to significant performance improvements. This method not only streamlines culling but also generates free screen space UV coordinates, enabling further enhancements like image-based point culling.
            </p>
        </div>

        <div class="content-box">
            <h2>The toolset includes:</h2>
            <p>
                <strong>- Frustum culling:</strong> Basic culling of objects outside the camera’s view.</br>
                <strong>- Image-based culling:</strong> Uses image luminosity to cull points based on visibility.</br>
                <strong>- Occlusion detection:</strong> Detects occlusion from terrain or other objects in the scene.</br>
                <strong>- Automated setup script:</strong> Automatically pulls camera data (lens length, sensor size, clipping distance, render resolution) and dynamically adjusts parameters, eliminating manual configuration.
            </p>
        </div>

        <div class="content-box">
            <h2>Key Features</h2>
            <p>
                - Up to 50% faster render times compared to rendering without the Camera Culler.
                - Efficient memory usage and reduced computational load.
                - Screen space UV coordinates that enable advanced culling techniques, such as image-based point culling.
            </p>
        </div>
        <div class="content-box">
            <h2>Earlier Versions and usecases</h2>
        </div>
        <div class="grid-item">
            <a>
                <video loop muted autoplay controls src="https://github.com/user-attachments/assets/f5919d59-1cda-444a-97e9-b9588e76801f" alt="Shuffled Points Video"></video>
            </a>
            <div class="description">
                Culling in space
            </div>
        </div>

        <div class="grid-item">
            <a>
                <video loop muted autoplay controls src="https://github.com/user-attachments/assets/6c34f10b-116c-47be-9a30-0b3aea72bff1" alt="Unshuffled Points Video"></video>
            </a>
            <div class="description">
                Grass culling
            </div>
        </div>

        <div class="content-box">
            <h2>Outcome</h2>
            <p>This tool delivers improved rendering speeds and offers greater control over scene optimization, making it ideal for complex 3D environments. It maintains high visual fidelity while reducing the resources needed for rendering.
            </p>
        </div>

        <div class="content-box">
            <h2>Skills & Technologies</h2>
            <p>
                <strong>- Blender:</strong> Developed and integrated the Camera Culler Node for rendering optimization.</br>
                <strong>- Python:</strong> Automated camera parameter adjustments and culling setup.</br>
                <strong>- Geometry Nodes:</strong> Used for both initial ray-casting and final screen space projection setup.</br>
                <strong>- Custom Culling Algorithms:</strong> Implemented frustum, image-based, and occlusion culling techniques.</br>
            </p>
        </div>
        
        <div class="content-box">
            <footer>© 2024 <a href="https://www.linkedin.com/in/jure-suli%C4%8D-9b700a195/">Jure Sulič</a></footer>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const contentBoxes = document.querySelectorAll('.content-box');
            const gridItems = document.querySelectorAll('.grid-item');
    
            // Add top border for content boxes
            contentBoxes.forEach(contentBox => {
                const previousElement = contentBox.previousElementSibling;
                if (previousElement && previousElement.classList.contains('grid-item')) {
                    contentBox.classList.add('has-top-border');
                }
            });
            
            // -----------------------------

            // Function to check and set borders for grid items
            function updateGridBorders() {
                const container = document.querySelector('.container');

                gridItems.forEach((gridItem, index) => {
                    // Reset borders
                    gridItem.style.borderRight = '1px solid #333'; // Default right border
                    // gridItem.style.borderTop = '1px solid #333';   // Default top border

                    // Get the width percentage of the grid item
                    const widthPercent = getGridItemWidthInPercent(gridItem);

                    // Get the count of previous grid items
                    const previousGridItemsCount = Array.from(gridItems).slice(0, index).filter(item => item.offsetParent !== null).length;

                    // Check conditions based on width percentage
                    if (index % 2 === 1){
                        gridItem.style.borderRight = '1px solid #fff';
                    } else {
                        gridItem.style.borderRight = '1px solid #333';
                    }
                });
            }

            // Function to get the width of a grid item in percentage
            function getGridItemWidthInPercent(gridItem) {
                const container = document.querySelector('.container');
                const gridItemStyle = window.getComputedStyle(gridItem);
                const gridItemWidth = parseFloat(gridItemStyle.width);
                const containerWidth = container.clientWidth;
                const widthPercent = (gridItemWidth / containerWidth) * 100;
                return widthPercent;
            }

            // Initial check
            updateGridBorders();

            // Update on window resize
            window.addEventListener('resize', updateGridBorders);
        });
    </script>
</body>
</html>
